# 7.1 概述

- 虚拟机的类加载机制：虚拟机把描述类的数据从Class文件 *加载* 到内存，并对数据进行 *校验* 、 *转换解析* 和 *初始化* ，最终形成可以被虚拟机直接使用的Java类型。
- 在Java语言里面，类型的加载和连接过程都是在 **程序运行期间** 完成的，这样会在类加载时 *稍微增加一些性能开销* ，但是却能为Java应用程序提供 *高度的灵活性* 。
- Java中天生可以 **动态扩展** 的语言特性就是依赖运行期 *动态加载* 和 *动态连接* 这个特点实现的。

# 7.2 类加载的时机

- 类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括： *加载(Loading)* 、 *验证(Verification)* 、 *准备(Preparation)* 、 *解析(Resolution)* 、 *初始化(Initialization)* 、 *使用(Using)* 和 *卸载(Unloading)* **七** 个阶段。

  ![jvm-tu-7.1](/assets/jvm-tu-7.1.png)

- 解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称作动态绑定或晚期绑定）。
- 对于初始化阶段，虚拟机规范严格规定了有且只有 **5种** 情况必须 *立即对类进行“初始化”* （而加载、验证、准备自然需要在此之前开始）：
  - 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。常见Java代码场景： *使用new关键字实例化对象* 的时候、 *读取或设置一个类的静态字段* （被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候 ，以及 *调用一个类的静态方法* 的时候。
  - 使用java.lang.reflect包的方法 *对类进行反射调用* 的时候，如果类没有进行初始化，则需要先触发其初始化。
  - *当初始化一个类的时候，如果发现其父类还没有进行过初始化* ，则需要先触发其 *父类* 的初始化。
  - 当虚拟机启动时， *用户指定一个要执行的主类* （包含main()方法的那个类），虚拟机会先初始化这个主类。
  - 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且 *这个方法句柄所对应的类没有进行过初始化* ，则需要先触发其初始化。
- 这5种场景中的行为称为对一个类进行 **主动引用** 。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。
- 3个例子说明何为被动引用：

  ```java
  package org.fenixsoft.classloading;
  /**
   *被动使用类字段演示一：
   *通过子类引用父类的静态字段，不会导致子类初始化。
   **/

  public class SuperClass{
    Static{
      System.out.println("SuperClass init!");
    }

    public static int value = 123;
  }

  public class SubClass extends SuperClass{
    Static{
      System.out.println("SubClass init!");
    }
  }



  public class NotInitialization{

    public static void main(String[] args){
      System.out.println(SubClass.value);
    }
  }
  ```

  - 上述代码运行之后，只会输出 SuperClass init! ，而 *不会输出* SubClass init! 。 **对于静态字段，只有直接定义这个字段的类才会被初始化** ，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

  ```java
  package org.fenixsoft.classloading;

  /**
   *被动使用类字段演示二：
   *通过数组定义类引用类，不会触发此类的初始化。
   **/

  public class NotInitialization{

    public static void main(String[] args){
      SuperClass[] sca = new SuperClass[10];
    }
  }
  ```

  - 上述代码运行之后发现没有输出 SuperClass init! ，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但触发了名为 *“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段* ，这是由虚拟机自动生成的、直接继承与java.lang.Object的子类，创建动作由字节码指令newarray触发。
  - 这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类中。
  - Java语言中对数组的访问比C/C++相对安全是因为 *这个类封装了数组元素的访问方法，而C/C++直接翻译为对数组指针的移动* 。

  ```java
  package org.fenixsoft.classloading;

  /**
   *被动使用类字段演示三：
   *常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
   **/

  public class ConstClass{

    static{
      System.out.println("ConstClass init!");
    }

    public static final String HELLOWORLD = "hello world";
  }


  public class NotInitialization{

    public static void main(String[] args){
      System.out.println(ConstClass.HELLOWORLD);
    }
  }
  ```

  - 上述代码运行之后，也没有输出 ConstClass init! ，因为 *在编译阶段将此常量的值“hello world”存储到了NotInitialization类的常量池中* ，对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。
  - 接口的加载过程与类加载过程稍有不同：一个接口在初始化时， *并不要求其父接口全部都完成初始化* ，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

# 7.3 类加载的过程

- Java虚拟机类加载的全过程：加载、验证、准备、解析、初始化。

## 7.3.1 加载

- 在加载阶段，虚拟机需要完成以下3件事情：
  - 通过一个类的全限定名来获取定义此类的二进制字节流。
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

- 相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成。
- 对于数组类而言，情况就有所不同， *数组本身不是通过类加载器创建，它是由Java虚拟机直接创建的* 。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（以下简称C）创建过程遵循如下规则：
  - 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。
  - 如果数组的组件类型不是引用类型（如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。
  - 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。

## 7.3.2 验证

- 验证是连接阶段的第一步，目的是为了 **确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全** 。

### 1.文件格式验证

- 第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

### 2.元数据验证

- 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。

### 3.字节码验证

- 第三阶段是整个验证过程最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

### 4.符号引用验证

- 最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配下校验。
- 符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClasccChangeError异常的子类。

## 7.3.3 准备

- 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
  - 首先，这个时候进行内存分配的 **仅包括类变量（被static修饰的变量）** ， **不包括实例变量** ，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
  - 其次，这里所说的初始值“通常情况”下是 **数据类型的零值** ，假设一个类变量的定义为：`public static int value = 123;` 那变量value在准备阶段过后的初始值为0而不是123，因为这个时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以 **把value赋值为123的动作将在初始化阶段才会执行** 。

    ![jvm-b-7.1](/assets/jvm-b-7.1.png)
  - “特殊情况”：如果类字段的字段属性表中 *存在ConstantValue属性* ，那么准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义为：`public static final int value = 123;` 编译是Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

## 7.3.4 解析

- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
  - 符号引用(Symbolic References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
  - 直接引用(Direct References)：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
- 虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这 *16* 个用于操作符号引用的字节码指令 *之前* ，先对它们所使用的符号引用进行解析。
- 对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行是常量池中记录直接引用，并不常量标识为已解析状态）从而避免解析动作重复进行。
- 对于invokedynamic指令，上面规则则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。
- 解析动作主要针对 *类或接口* 、 *字段* 、 *类方法* 、 *接口方法* 、 *方法类型* 、 *方法句柄* 和 *调用点限定符* 7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型。

### 1.类或接口的解析

- 假设当前代码所处的类为D，如果把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：
  - 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。
  - 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer]”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
  - 如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。

### 2.字段解析

- 要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析成功，那将这个字段所属的类或接口用C表示，虚拟机规范按照如下步骤对C进行后续字段的搜索：
  - 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  - 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  - 否则，如果C不是java.lang.Object的话，将会按照继承关系从上到下递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  - 否则，查找失败，抛出java.lang.NoSuchFieldErrod异常。

### 3.类方法解析

- 类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，将会按照如下步骤进行后续的类方法搜索：
  - 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
  - 如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
  - 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
  - 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。
  - 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。

### 4.接口方法解析

- 接口方法也需要先解析接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，如下步骤进行后续的接口方法搜索：
  - 与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
  - 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
  - 否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
  - 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。

## 7.3.5 初始化

- 初始化阶段是执行类构造器<clinit>()方法的过程。
- <clinit>()方法是*由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的* ，编译器收集的顺序是 *由语句在源文件中出现的顺序所决定的* ，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但 *不可以访问*。

  ```java
  public class Test{
    static{
      i = 0;   //给变量赋值可以正常编译通过
      System.out.print(i); //这句编译器会提示“非法向前引用”。
    }
    static int i = 1;
  }
  ```

- <clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此 **在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object** 。

- 由于父类的<clinit>()方法先执行，也就意味着 **父类中定义的静态语句块要优先于子类的变量赋值操作**

    ```java
    static class Parent{
      public static int A = 1;
      static{
        A = 2;
      }
    }

    Static class Sub extends Parent{
      public static int B = A;
    }

    public static void main(String[] args){
      System.out.println(Sub.B);   //字段B的值输出为2而不是1
    }
    ```

- <clinit>()方法对于类或接口来说 *并不是必须* 的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。

- **接口中不能使用静态语句块** ，但仍然有变量初始化的赋值操作，因此接口与类一样都会产生<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外， **接口的实现类在初始化时也一样不会执行接口的<clinit>()方法** 。

- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么 *只会有一个线程* 去执行这个类的<clinit>()方法，其他线程都需要 *阻塞* 等待，直到活动线程执行<clinit>()方法完毕。

# 7.4 类加载器

- 把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 *Java虚拟机外部去实现* ，实现这个动作的代码模块称为“类加载器”。

## 7.4.1 类与类加载器

- 对于任意一个类，都需要由 *加载它的类加载器* 和 *这个类本身* 一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
- 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里指的“相等”，包括代表类的Class对象的 *equals方法* 、 *isAssisgnableFrom()方法*、 *isInstance()方法的返回结果* ，也包括 *使用instanceof关键字做对象所属关系判定* 等情况。

## 7.4.2 双亲委派模型

- 绝大部分Java程序都会使用到以下3种系统提供的类加载器：
  - 启动类加载器(Bootstrap ClassLoader)：启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。
  - 扩展类加载器(Extension ClassLoader)：开发者可以直接使用扩展类加载器。
  - 应用程序加载器(Application ClassLoader)：由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也被称为 **系统类加载器** 。他负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器。一般情况下这个就是程序中默认的类加载器。

- 下图，类加载器之间的这种层次关系，称为加载器的 **双亲委派模型(Parents Delegation Model)** 。

  ![jvm-tu-7.2](/assets/jvm-tu-7.2.png)

- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都是应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系实现，而是都使用 *组合(Composition)* 关系来复用父加载器的代码。

- 双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先 *不会* 自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的都如此， **因此所有的加载请求最终都应该传送到顶层的启动类加载器中** ， 只有当福类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载，

## 7.4.3 破坏双亲委派模型

- 双亲委派模型有3次较大规模的“被破坏”情况：
  - *重写loadClass()方法* ，解决办法：把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载。
  - *基础类要调用回用户的代码* ，如JNDI服务，为了能对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者(SPI, Service Provider Interface)的代码。解决办法：
    - *线程上下文类加载器(Thread Context ClassLoader)* 。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
    - JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是福类加载器请求子类加载器去完成类加载的动作。Java中所有涉及 *SPI* 的加载动作基本上采用这种方式，如 *JNDI* 、*JDBC* 、 *JCE* 、 *JAXB* 和 *JBI* 等。
  - 第三次破坏是由于用户对程序动态性（如代码热替换(HotSwap)、模块热部署(Hot Deployment)等）的追求而导致的。 无解，目前OSGi已经成为业界的Java模块化标准。
