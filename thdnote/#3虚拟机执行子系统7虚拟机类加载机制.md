# 7.1 概述

- 虚拟机的类加载机制：虚拟机把描述类的数据从Class文件 *加载* 到内存，并对数据进行 *校验* 、 *转换解析* 和 *初始化* ，最终形成可以被虚拟机直接使用的Java类型。
- 在Java语言里面，类型的加载和连接过程都是在 **程序运行期间** 完成的，这样会在类加载时 *稍微增加一些性能开销* ，但是却能为Java应用程序提供 *高度的灵活性* 。
- Java中天生可以 **动态扩展** 的语言特性就是依赖运行期 *动态加载* 和 *动态连接* 这个特点实现的。

# 7.2 类加载的时机

- 类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括： *加载(Loading)* 、 *验证(Verification)* 、 *准备(Preparation)* 、 *解析(Resolution)* 、 *初始化(Initialization)* 、 *使用(Using)* 和 *卸载(Unloading)* **七** 个阶段。

  ![jvm-tu-7.1](/assets/jvm-tu-7.1.png)

- 解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称作动态绑定或晚期绑定）。
- 对于初始化阶段，虚拟机规范严格规定了有且只有 **5种** 情况必须 *立即对类进行“初始化”* （而加载、验证、准备自然需要在此之前开始）：
  - 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。常见Java代码场景： *使用new关键字实例化对象* 的时候、 *读取或设置一个类的静态字段* （被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候 ，以及 *调用一个类的静态方法* 的时候。
  - 使用java.lang.reflect包的方法 *对类进行反射调用* 的时候，如果类没有进行初始化，则需要先触发其初始化。
  - *当初始化一个类的时候，如果发现其父类还没有进行过初始化* ，则需要先触发其 *父类* 的初始化。
  - 当虚拟机启动时， *用户指定一个要执行的主类* （包含main()方法的那个类），虚拟机会先初始化这个主类。
  - 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且 *这个方法句柄所对应的类没有进行过初始化* ，则需要先触发其初始化。
- 这5种场景中的行为称为对一个类进行 **主动引用** 。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。
- 3个例子说明何为被动引用：

  ```java
  package org.fenixsoft.classloading;
  /**
   *被动使用类字段演示一：
   *通过子类引用父类的静态字段，不会导致子类初始化。
   **/

  public class SuperClass{
    Static{
      System.out.println("SuperClass init!");
    }

    public static int value = 123;
  }

  public class SubClass extends SuperClass{
    Static{
      System.out.println("SubClass init!");
    }
  }



  public class NotInitialization{

    public static void main(String[] args){
      System.out.println(SubClass.value);
    }
  }
  ```

  - 上述代码运行之后，只会输出 SuperClass init! ，而 *不会输出* SubClass init! 。 **对于静态字段，只有直接定义这个字段的类才会被初始化** ，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

  ```java
  package org.fenixsoft.classloading;

  /**
   *被动使用类字段演示二：
   *通过数组定义类引用类，不会触发此类的初始化。
   **/

  public class NotInitialization{

    public static void main(String[] args){
      SuperClass[] sca = new SuperClass[10];
    }
  }
  ```

  - 上述代码运行之后发现没有输出 SuperClass init! ，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但触发了名为 *“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段* ，这是由虚拟机自动生成的、直接继承与java.lang.Object的子类，创建动作由字节码指令newarray触发。
  - 这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类中。
  - Java语言中对数组的访问比C/C++相对安全是因为 *这个类封装了数组元素的访问方法，而C/C++直接翻译为对数组指针的移动* 。

  ```java
  package org.fenixsoft.classloading;

  /**
   *被动使用类字段演示三：
   *常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
   **/

  public class ConstClass{

    static{
      System.out.println("ConstClass init!");
    }

    public static final String HELLOWORLD = "hello world";
  }


  public class NotInitialization{

    public static void main(String[] args){
      System.out.println(ConstClass.HELLOWORLD);
    }
  }
  ```

  - 上述代码运行之后，也没有输出 ConstClass init! ，因为 *在编译阶段将此常量的值“hello world”存储到了NotInitialization类的常量池中* ，对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。
  - 接口的加载过程与类加载过程稍有不同：一个接口在初始化时， *并不要求其父接口全部都完成初始化* ，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

# 7.3 类加载的过程

- Java虚拟机类加载的全过程：加载、验证、准备、解析、初始化。

## 7.3.1 加载

- 在加载阶段，虚拟机需要完成以下3件事情：
  - 通过一个类的全限定名来获取定义此类的二进制字节流。
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

- 相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成。
- 对于数组类而言，情况就有所不同， *数组本身不是通过类加载器创建，它是由Java虚拟机直接创建的* 。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（以下简称C）创建过程遵循如下规则：
  - 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。
  - 如果数组的组件类型不是引用类型（如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。
  - 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。

## 7.3.2 验证

- 验证是连接阶段的第一步，目的是为了 **确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全** 。
