# 3.2 对象已死？

## 3.2.1 引用计数算法(Reference Counting)

- 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器只就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。
- 该方法实现简单，判定效率也很高： *微软的COM(Component Object Model)技术、使用ActionScript3的FlashPlayer、Python、Squirrel等* 。
- Java没有选用引用计数算法，因为该方法 *很难解决对象之间的相互循环引用的问题* 。

## 3.2.2 根搜索算法(GC Roots Tracting)

- 通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连（用图论的话说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

  ![jvm-tu-3.1](/assets/jvm-tu-3.1.png)

-  *Java、c#、Lisp*
- 在Java中，可作为GC Roots的对象包括下面几种：
  - 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
  - 方法区中的类静态属性引用的对象。
  - 方法区中的常量引用的对象。
  - 本地方法栈中JNI（即一般说的Native方法）的引用的对象。

## 3.2.3 再谈引用

- 强引用(Strong Reference)是指在代码之中普遍存在的，类似`Object obj = new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用(Soft Reference)用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。SoftReference类实现。
- 弱引用(Weak Reference)也是用来描述非必需对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类实现。
- 虚引用(Phantom Reference)也称为幽灵引用或者幻影引用，最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。对一个对象设置虚引用关联的目的是希望能在这个对象被收集器回收时收到一个系统通知。PantomReference类实现。

## 3.2.5 回收方法区

- 回收废弃常量和无用类
- 回收废弃常量与回收Java堆中的对象非常类似
- 而判定一个类是无用类需满足以下3个条件：
    - 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
    - 加载该类的ClassLoader已经被回收。
    - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 3.3 垃圾收集算法

## 3.3.1 标记-清除算法(Mark-Sweep)

- 首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
- 缺点：
  - 效率问题：标记和清除过程的效率都不高
  - 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![jvm-tu-3.2](/assets/jvm-tu-3.2.png)

## 3.3.2 复制算法(Coping)

- 将可用内存按容量划分为大小相同的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
- 这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
- 代价是将内存缩小为原来一半。

![jvm-tu-3.3](/assets/jvm-tu-3.3.png)

- 现在的商业虚拟机都采用这种收集算法回收新生代。将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survior中还存活的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。

## 3.3.3 标记-整理算法(Mark-Compact)

- 标记过程和“标记-清除”算法一样，然后让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。

![jvm-tu-3.4](/assets/jvm-tu-3.4.png)

## 3.3.4 分代收集算法(Generational Collection)

- 根据对象的存活周期的不同将内存化分为几块。一般是把Java堆分为新生代和老生代。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老生代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

# 3.4 垃圾收集器

![jvm-tu-3.5](/assets/jvm-tu-3.5.png)

- 上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。

## 3.4.1 Serial收集器

- 一个单线程的收集器，在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。复制算法

![jvm-tu-3-6](/assets/jvm-tu-3-6.png)

- 简单高效。对于运行在Client模式下的虚拟机是个很好的选择。

## 3.4.2 ParNew收集器

- Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX：PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器 *完全一样* 。

![jvm-tu-3.7](/assets/jvm-tu-3.7.png)

- 许多运行在Server模式下的虚拟机中首选的新生代收集器。 **目前只有它能与CMS收集器配合工作** 。
- 可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。

## 3.4.3 Parallel Scavenge 收集器

- 也是一个新生代收集器，也使用 *复制算法* ，也是并行的多线程收集器。
- 但关注点不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是 **达到一个可控制的吞吐量(Throughput)** 。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。
- 停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提高用户的体验；而高吞吐量则可以高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合 *在后台运算而不需要太多交互的任务* 。
- 提供：控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数和直接设置吞吐量大小的-XX:GCTimeRatio参数。
- MaxGCPausrMillis参数允许的值是一个大于0的毫秒数。
- GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。
- 也被称为 *“吞吐量优先”收集器* 。
- 开关参数-XX:+UseAdaptiveSizePolicy：打开后，就不需要手工指定新生代的大小(-Xmm)、Eden与Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了。称为GC自适应的调节策略(GC Ergonomics)

## 3.4.4 Serial Old 收集器

- Serial收集器的老年代版本，单线程收集器，使用“标记-整理”算法，主要被Client模式下的虚拟机使用。
- 如果用于Server模式，他主要有两大用途：一是JDK1.5及之前的版本与Parallel Scavenge收集器搭配使用；另一个是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。

![jvm-tu-3.8](/assets/jvm-tu-3.8.png)

## 3.4.5 Parallel Old 收集器

- Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
- 在注重吞吐量及CPU资源敏感的场合，都可优先考虑Parallel Scavenge加Parallel Old收集器。

![jvm-tu-3.9](/assets/jvm-tu-3.9.png)

## 3.4.6 CMS收集器

- CMS(Concurrent Mark Sweep)收集器是一种以 **获取最短回收停顿时间** 为目标的收集器。
- 适合用于重视服务的响应速度，希望停顿时间最短，以给用户带来较好的体验的Java应用。
- 基于“标记-清除”算法实现。整个运作过程分为4个步骤：
  - 初始标记(CMS initial mark)，需“Stop The World”，仅仅标记一下GC Roots能直接关联到的对象，速度很快。
  - 并发标记(CMS concurrent mark)，进行GC Roots Tracing的过程。
  - 重新标记(CMS remark)，需“Stop The World”，修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
  - 并发清除(CMS concurrent sweep)。

![jvm-tu-3.10](/assets/jvm-tu-3.10.png)

- 优点：并发收集、低停顿。
- 缺点：
  - CMS收集器对CPU资源非常敏感。会导致应用程序变慢，总吞吐量降低。
  - CMS收集器无法处理浮动垃圾(Floating Garbage)，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生，
  - 收集结束时可能产生大量空间碎片。

## 3.4.7 G1收集器

- 基于“标记-整理”算法
- 可以精确控制停顿
- G1将整个Java堆（包括新生代、老生代）划分为多个大小固定的独立区域(Region)，并且跟踪这些区域里的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先收集垃圾最多的区域。

## 3.4.8 垃圾收集器参数总结

![jvm-b-3.1](/assets/jvm-b-3.1.png)

# 3.5 内存策略与回收策略

## 3.5.1 对象优先在Eden分配

- 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分PE时，虚拟机将发起一次Minor GC。
- 新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较块。
- 老年代GC(Major GC / Full GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在ParallelScavenge收集器的收集策略里就直接进行Major GC的策略选择过程）。MajorGC的速度一般会比Minor GC慢10倍以上。

## 3.5.2 大对象直接进入老年代

- 所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串及数组。
- 虚拟机提供一个 -XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配。

## 3.5.3 长期存活的对象将进入老年代

- 虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，用-XX:MaxTenuringThreshold设置）时，就会被晋升到老年代。

## 3.5.4 动态对象年龄判定

- 如果在Survivor空间中 *相同年龄所有对象大小的总和* 大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

## 3.5.5 空间分配担保

- 在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。
