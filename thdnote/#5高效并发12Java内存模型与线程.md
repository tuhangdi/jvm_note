# 12.1 概述

- 计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在 *磁盘I/O* 、 *网络通信* 或者 *数据库访问* 上。
- 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数(Transactions Per Second, TPS)是最重要的指标之一，它代表着一秒内服务器平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。

# 12.2 硬件的效率与一致性

- 由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的 **高速缓存(Cache)** 来作为内存与处理器之间的缓冲： *将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了* 。
- 但这带来了一个新的问题： **缓存一致性(Cache Coherence)** ：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。

  ![jvm-tu-12.1](/assets/jvm-tu-12.1.png)

- 为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI(Illinois Protocol)、MOSI、Synapse、Firefly及Dragon Protocol等。
- 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行 **乱序执行(Out-Of-Order Execution)** 优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。
- 与之相似，Java虚拟机的即时编译器中也有类似的 **指令重排序(Instruction Reorder)** 优化。

# 12.3 Java内存模型

- 在Java虚拟机规范中视图定义一种Java内存模型(Java Memory Model，JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，已实现让Java程序在各种平台下都能达到一致的内存访问效果。

## 12.3.1 主内存与工作内存

- Java内存模型的主要目标是定义程序中各个变量的 **访问规则** ，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量(Variables)与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，到 *不包括局部变量与方法参数* ，因为后者是线程私有的，不会被共享。
- Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。
- Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。
- 每条线程还有自己的工作内存(Working Memory)，保存了被该线程使用到的变量的主内存副本拷贝，
  - 线程对变量的所有操作（读取、赋值等）都 **必须在工作内存** 中进行，而不能直接读写内存中的变量。
  - 不同的线程之间也 **无法直接访问对方工作内存中的变量** ，线程间变量值的传递均需要通过主内存来完成。

  ![jvm-tu-12.2](/assets/jvm-tu-12.2.png)

## 12.3.2 内存间交互操作

- 关于主内存与工作内存之间具体的交互协议，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面体积的每一种操作都是 **原子的** 、 **不可再分的** 。
  - lock（锁定）：作用于 **主内存** 的变量，它把一个变量标识为一条线程独占的状态。
  - unlock（解锁）：作用于 **主内存** 的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
  - read（读取）：作用于 **主内存** 的变量，它把一个变量的值从 *主内存* 传输到线程的 *工作内存* 中，以便随后的load动作使用。
  - load（载入）：作用于 **工作内存** 的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
  - use（使用），作用于 **工作内存** 的变量，它把 *工作内存* 中一个变量的值传递给 *执行引擎* ，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
  - assign（赋值）：作用于 **工作内存** 的变量，它把一个从 *执行引擎* 接收到的值赋给 *工作内存* 的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
  - store（存储）：作用于 **工作内存** 的变量，它把 *工作内存* 中一个变量的值传送到 *主内存* 中，以便随后的write操作使用。
  - write(写入)：作用于 **主内存** 的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

- 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步会主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按 *顺序执行* ，而没有保证是 *连续执行* 。
- Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
  - 不允许read和load、store和write操作之一单独出现，即 *不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现* 。
  - 不允许一个线程丢弃它的最近的assign操作，即 *变量在工作内存中改变了之后必须把该变化同步回主内存* 。
  - *不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中* 。
  - *一个新的变量只能在主内存中“诞生”* ，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，即对一个变量实施use、store操作之前，必须先执行过了assign和load操作。
  - *一个变量在同一个时刻只允许一条线程对其进行lock操作* ，但lock操作可以被 *同一条线程* 重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
  - *如果对一个变量执行lock操作，那将会清空工作内存中此变量的值* ，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
  - 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
  - 对一个变量执行unlock操作之前，必须 *先把此变量同步回主内存中(执行store、write操作)* 。

## 12.3.3 对于volatile型变量的特殊规则

- 当一个变量定义为volatile之后，它将具备两种特性。
  - 第一是保证此变量对所有线程的 *可见性* 。这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。但volatile变量只能保证可见性，在 **不符合** 以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证 *原子性* 。
    - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
    - 变量不需要与其他的状态变量共同参与不变约束。

  - 使用volatile变量的第二个语义是 *禁止指令重排序优化* 。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。而volatile赋值后有类似内存屏障(Memory Barrier/Memory Fence)，重排序时不能把后面的指令重排序到内存屏障之前的位置。
- 大多数场景下 *volatile的总开销仍然要比锁低* ，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。
- Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile型变量。
  - 要求在工作内存中，每次使用V前都必须先从主内存 *刷新* 最新的值，用于保证能看见其他线程对变量V所做的修改后的值。
  - 要求在工作内存中，每次修改V后都必须立刻 *同步* 回主内存，用于保证其他线程可以看到自己对变量V所做的修改。
  - 要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。

## 12.3.5 原子性、可见性与有序性

- **原子性(Atomicity)** ：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为 *基本数据类型* 的访问读写是具备原子性的。
- 尽管虚拟机未把lock和unlock操作直接开始给用户使用，但却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此 *在synchronized块之间的操作也具备原子性* 。
- **可见性(Visibility)** ：
