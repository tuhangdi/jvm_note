# 12.1 概述

- 计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在 *磁盘I/O* 、 *网络通信* 或者 *数据库访问* 上。
- 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数(Transactions Per Second, TPS)是最重要的指标之一，它代表着一秒内服务器平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。

# 12.2 硬件的效率与一致性

- 由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的 **高速缓存(Cache)** 来作为内存与处理器之间的缓冲： *将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了* 。
- 但这带来了一个新的问题： **缓存一致性(Cache Coherence)** ：在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。

  ![jvm-tu-12.1](/assets/jvm-tu-12.1.png)

- 为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI(Illinois Protocol)、MOSI、Synapse、Firefly及Dragon Protocol等。
- 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行 **乱序执行(Out-Of-Order Execution)** 优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。
- 与之相似，Java虚拟机的即时编译器中也有类似的 **指令重排序(Instruction Reorder)** 优化。

# 12.3 Java内存模型

- 在Java虚拟机规范中视图定义一种Java内存模型(Java Memory Model，JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，已实现让Java程序在各种平台下都能达到一致的内存访问效果。

## 12.3.1 主内存与工作内存

- Java内存模型的主要目标是定义程序中各个变量的 **访问规则** ，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量(Variables)与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，到 *不包括局部变量与方法参数* ，因为后者是线程私有的，不会被共享。
- Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。
- Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。
- 每条线程还有自己的工作内存(Working Memory)，保存了被该线程使用到的变量的主内存副本拷贝，
  - 线程对变量的所有操作（读取、赋值等）都 **必须在工作内存** 中进行，而不能直接读写内存中的变量。
  - 不同的线程之间也 **无法直接访问对方工作内存中的变量** ，线程间变量值的传递均需要通过主内存来完成。

  ![jvm-tu-12.2](/assets/jvm-tu-12.2.png)

## 12.3.2 内存间交互操作

- 关于主内存与工作内存之间具体的交互协议，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面体积的每一种操作都是 **原子的** 、 **不可再分的** 。
  - lock（锁定）：作用于 **主内存** 的变量，它把一个变量标识为一条线程独占的状态。
  - unlock（解锁）：作用于 **主内存** 的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
  - read（读取）：作用于 **主内存** 的变量，它把一个变量的值从 *主内存* 传输到线程的 *工作内存* 中，以便随后的load动作使用。
  - load（载入）：作用于 **工作内存** 的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
  - use（使用），作用于 **工作内存** 的变量，它把 *工作内存* 中一个变量的值传递给 *执行引擎* ，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
  - assign（赋值）：作用于 **工作内存** 的变量，它把一个从 *执行引擎* 接收到的值赋给 *工作内存* 的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
  - store（存储）：作用于 **工作内存** 的变量，它把 *工作内存* 中一个变量的值传送到 *主内存* 中，以便随后的write操作使用。
  - write(写入)：作用于 **主内存** 的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

- 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步会主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按 *顺序执行* ，而没有保证是 *连续执行* 。
- Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
  - 不允许read和load、store和write操作之一单独出现，即 *不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现* 。
  - 不允许一个线程丢弃它的最近的assign操作，即 *变量在工作内存中改变了之后必须把该变化同步回主内存* 。
  - *不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中* 。
  - *一个新的变量只能在主内存中“诞生”* ，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，即对一个变量实施use、store操作之前，必须先执行过了assign和load操作。
  - *一个变量在同一个时刻只允许一条线程对其进行lock操作* ，但lock操作可以被 *同一条线程* 重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
  - *如果对一个变量执行lock操作，那将会清空工作内存中此变量的值* ，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
  - 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
  - 对一个变量执行unlock操作之前，必须 *先把此变量同步回主内存中(执行store、write操作)* 。

## 12.3.3 对于volatile型变量的特殊规则

- 当一个变量定义为volatile之后，它将具备两种特性。
  - 第一是保证此变量对所有线程的 *可见性* 。这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。但volatile变量只能保证可见性，在 **不符合** 以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证 *原子性* 。
    - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
    - 变量不需要与其他的状态变量共同参与不变约束。

  - 使用volatile变量的第二个语义是 *禁止指令重排序优化* 。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。而volatile赋值后有类似内存屏障(Memory Barrier/Memory Fence)，重排序时不能把后面的指令重排序到内存屏障之前的位置。
- 大多数场景下 *volatile的总开销仍然要比锁低* ，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。
- Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile型变量。
  - 要求在工作内存中，每次使用V前都必须先从主内存 *刷新* 最新的值，用于保证能看见其他线程对变量V所做的修改后的值。
  - 要求在工作内存中，每次修改V后都必须立刻 *同步* 回主内存，用于保证其他线程可以看到自己对变量V所做的修改。
  - 要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。

## 12.3.5 原子性、可见性与有序性

- **原子性(Atomicity)** ：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为 *8种基本数据类型* 的访问读写是具备原子性的。
- 尽管虚拟机未把lock和unlock操作直接开始给用户使用，但却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—— *synchronized* 关键字，因此 *在synchronized块之间的操作也具备原子性* 。
- **可见性(Visibility)** ：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过 *在变量修改后将新值同步回主内存* ， *在变量读取前从主内存刷新变量值* 这种依赖主内存作为传媒介质的方式来实现可见性的。
- *volatile* 保证了多线程操作时变量的可见性。除此之外，Java还有两个关键字能实现可见性，即 *synchronized* 和 *final* 。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那在其他线程中就能看见final字段的值。
- **有序性(Ordering)** ：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
- Java语言提供了 *volatile* 和 *synchronized* 两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条原则决定了持有同一个锁的两个同步块只能串行地进入。

## 12.3.6 先行发生原则

- 下面是Java内存模型下一些“天然的”先行发生关系，无须任何同步手段。
  - **程序次序规则(Program Order Rule)** ：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
  - **管程锁定规则(Monitor Lock Rule)** ：一个unlock操作先行发生于后面对同一个锁的lock操作。
  - **volatile变量规则(Volatile Variable Rule)** ：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
  - **线程启动规则(Thread Start Rule)** ：Thread对象的start()方法先行发生于此线程的每一个动作。
  - **线程终止规则(Thread Termination Rule)** ：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
  - **线程中断规则(Thread Interruption Rule)** ：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
  - **对象终结规则(Finalizer Rule)** ：一个对象的初始化完成（构造函数执行结束）先行发生与它的finalize()方法的开始。
  - **传递性(Transitivity)** ：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生与操作C的结论。

# 12.4 Java与线程

## 12.4.1 线程的实现

- 各个线程既可以共享进度资源（内存地址、文件I/O等），又可以独立调度（ **线程是CPU调度的基本单位** ）。
- 实现线程主要有3种方式： *使用内核线程实现* 、 *使用用户线程实现* 和 *使用用户线程加轻量级进程混合实现* 。

### 1.使用内核线程实现

- 内核线程(Kernel-Level Thread,KLT)就是直接由操作系统内核(Kernel)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视作内核的一个分身，支持多线程的内核就叫做多线程内核(Multil-Threads Kernel)。
- 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process, LWP)，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为 *一对一的线程模型* 。

  ![jvm-tu-12.3](/assets/jvm-tu-12.3.png)

- 局限性
  - 首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换。
  - 其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

### 2.使用用户线程实现

- 用户线程(User Thread)的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助，这种线程不需要切换到内核态，因此操作可以是 *非常快速且低消耗的* ，也可以 *支持规模更大的线程数量* 。
- 这种进程与用户线程之间1：N的关系称为一对多的线程模型。

  ![jvm-tu-12.4](/assets/jvm-tu-12.4.png)

### 3.使用用户线程加轻量级进程混合实现

- *用户线程还是完全建立在用户空间中* ，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的 *轻量级进程则作为用户线程和内核线程之间的桥梁* ，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的 *系统调用通过轻量级线程来完成* ，大大降低了整个进程被完全阻塞的风险。
- 用户线程与轻量级进程的数量比是不定的，即为N:M的关系，称为多对多的线程模型。

  ![jvm-tu-12.5](/assets/jvm-tu-12.5.png)

### 4.Java线程的实现

- 对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中。

## 12.4.2 Java线程调度

- 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是 **协同式线程调度(Cooperative Threads-Scheduling)** 和 **抢占式线程调度(Preemptive Threads-Scheduling)** 。
- 如果使用 *协同式调度* 的多线程系统，*线程的执行时间由线程本身来控制* ，线程把自己的工作执行完了之后，要主动通知系统切换到另一个线程上。实现简单，没有线程同步问题，但线程执行时间不可控制，可能导致阻塞。Lua语言的“协同例程”就是这类实现。
- 如果使用 *抢占式调度* 的多线程系统，那么每个线程将 *由系统来分配执行时间* ，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。线程的执行时间可控，也不会有一个线程导致整个进程阻塞的问题。Java使用抢占式调度。
- 可以通过设置线程优先级来给系统“建议”给某些线程多分配一点执行时间。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）。

## 12.4.3 状态转换

- Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态。
  - **新建(New)** ：创建后尚未启动的线程处于这种状态。
  - **运行(Runalbe)** ：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
  - **无限期等待(Waiting)** ：处于这种状态的线程不会被分配CPU执行时间，它们要 *等待被其他线程显示地唤醒* 。以下方法会让线程陷入无限期的等待状态：
    - 没有设置Timeout参数的Object.wait()方法
    - 没有设置Timeout参数的Thread.join()方法
    - LockSupport.park()方法
  - **限期等待(Timed Waiting)** ：处于这种状态的线程 *也不会* 被分配CPU执行时间，不过在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
    - Thread.sleep()方法
    - 设置了Timeout参数的Object.wait()方法
    - 设置了Timeout参数的Thread.join()方法
    - LockSupport.parkNamos()方法
    - LockSupport.parkUntil()方法
  - **阻塞(Blocked)** :线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个 *排他锁* 。这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。 *在程序等待进入同步区域的时候，线程将进入这种状态。*
  - **结束(Terminated)** ：已终止线程的线程状态，线程已经结束执行。
- 上述5种状态在遇到特定事件发生的时候将会互相转换，如图。

  ![jvm-tu-12.6](/assets/jvm-tu-12.6.png)
