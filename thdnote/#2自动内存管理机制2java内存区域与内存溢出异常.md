# 2.2 运行时数据区域

![jvm-tu-2.1](/assets/jvm-tu-2.1.png)

## 2.2.1 程序计数器(Program Counter Register)

- 一块较小的内存空间
- 当前线程所执行的字节码的行号指示器
- **线程私有** （由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互补影响，独立存储，我们称这类内存区域为“线程私有”的内存）。
- 如果线程正在执行一个Java方法，计数器记录 *正在执行的虚拟机字节码指令的地址*
- 如果线程正在执行的是Native方法，计数器 *值为空(Undefined)*
- 此内存区域是 *唯一一个* 在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## 2.2.2 Java虚拟机栈(Java Virtual Machine Stacks)

- 线程私有
- 生命周期与线程相同
- 每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储 *局部变量表* 、 *操作栈* 、 *动态链接* 、*方法出口* 等信息。
- 每一个方法被调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
- 局部变量表存放了编译器可知的各种 *基本数据类型* (boolean、byte、char、short、int、float、long、double)、 *对象引用* （reference类型，它不等同于对象本身，根据不同虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可以指向一个代表对象的句柄或者其他与此对象相关的位置）和 *returnAddress类型* （指向了一条字节码指令的地址）。
- 64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。
- 局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不改变大小。
- 两种异常情况：
  - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
  - 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常

## 2.2.3 本地方法栈(Native Method Stacks)

- 与虚拟机栈所发挥的作用非常相似
- 与虚拟机栈区别：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。
- StackOverflowError，OutOfMemoryError

## 2.2.4 Java堆(Java Heap)

- Java虚拟机所管理的内存中最大的一块
- 被所有 **线程共享** 的一块内存区域，在虚拟机启动时创建。
- 唯一目的就是 **存放对象实例** 。
- 是垃圾收集器管理的主要区域，也被称作“GC堆”。
- Java堆可以处于物理上不连续的内存空间中，只要是逻辑上是连续的即可。
- 既可以实现成固定大小，也可以是可扩展的。
- 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将抛出OutOfMemoryError异常。

## 2.2.5 方法区(Method Area)

- 各个 **线程共享** 的内存区域
- 存储已被虚拟机夹在的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 2.2.6 运行时常量池(Runtime Constant Pool)

- 方法区的一部分
- Class文件中除了有类 的版本、字段、方法、接口等描述等信息歪，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
- 具备动态性，运用于String类的intern()方法
- 当常量池无法再申请到内存时会抛出OutOfMemoryError异常

## 2.2.7 直接内存(Direct Memory)

- 不是虚拟机运行时数据区的一部分，但这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常。

# 2.3 对象访问

- `Object obj = new Object();`
  - `Object obj`这部分的语义将会反映到 *Java栈*的本地变量表中，作为一个reference类型数据出现。
  - `new Object()`这部分的语义将反映到 *Java堆* 中，形成一块存储了Object类型所有实例数值（Instance Data，对象中各个实例字段的数据）的结构化内存，这块内存的长度是 *不固定* 的。
  - 主流的访问方式：
    - 句柄访问方式：Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的 *句柄地址* ，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。优势： *reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而refrence本身不需要被修改。*

      ![jvm-tu-2.2](/assets/jvm-tu-2.2.png)

    - 直接指针访问方式：reference中直接存储的就是对象地址。优势： *速度更快，节省了一次指针定位的时间开销。*

      ![jvm-tu-2.3](/assets/jvm-tu-2.3.png)
